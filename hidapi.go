package main

import "C"
import (
	"fmt"
	"github.com/sstallion/go-hid"
	"log"
	"strconv"
)

const (
	LightMax = 0x00
	LightMin = 0xff
)

var (
	CloseLEDS  = []byte{0x04, 0x86, 0x94, 0xc1, 0x6a, 0x0d, 0x70, 0x98, 0x49, 0xec, 0x69, 0xd3, 0x59, 0x98, 0x8d, 0x75, 0x06, 0x95, 0xee, 0xed, 0x2f}
	OpenLEDS   = []byte{0x04, 0x86, 0x94, 0xc1, 0x6a, 0x0d, 0x70, 0x98, 0x49, 0xed, 0x69, 0xd3, 0x59, 0x98, 0x8d, 0x75, 0x06, 0x95, 0xee, 0xed, 0x2f}
	AlwayGreen = []byte{0x04, 0x86, 0x93, 0xcc, 0x8f, 0xdf, 0xe7, 0xdf, 0x49, 0x58, 0x9e, 0x27, 0x69, 0x26, 0x9e, 0x0f, 0x86, 0x0a, 0x41, 0x08, 0x61}
	AlwayRed   = []byte{0x04, 0x86, 0x93, 0xcc, 0x73, 0x96, 0xc1, 0xa7, 0x49, 0xa7, 0x61, 0x27, 0x66, 0xe1, 0xa6, 0x94, 0x50, 0x60, 0x57, 0x48, 0xca}
	AlwayBlue  = []byte{0x04, 0x86, 0x93, 0xcc, 0xaf, 0x2b, 0xeb, 0xd6, 0x49, 0x58, 0x61, 0xd8, 0xce, 0xef, 0xd5, 0xf2, 0xbb, 0x28, 0x18, 0xec, 0x9d}
	FENGCHE    = []byte{0x04, 0x86, 0x93, 0xc7, 0xe2, 0xe1, 0x5b, 0x1a, 0x6f, 0x8e, 0xb0, 0x96, 0x74, 0x64, 0x9e, 0xa6, 0xf6, 0x35, 0xb2, 0xdb, 0x30}
	JianBian   = []byte{0x04, 0x86, 0x93, 0xca, 0x68, 0x87, 0x72, 0x99, 0x48, 0x58, 0x61, 0x27, 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	LiuGuang   = []byte{0x04, 0x86, 0x93, 0xcb, 0xae, 0xfb, 0x72, 0x99, 0x48, 0x58, 0x61, 0x27, 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	XinKong    = []byte{0x04, 0x86, 0x93, 0xc8, 0x33, 0xfd, 0x72, 0x99, 0x48, 0x58, 0x61, 0x27, 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	GunDong    = []byte{0x04, 0x86, 0x93, 0xc9, 0x2a, 0xed, 0x72, 0x99, 0x48, 0x58, 0x61, 0x27, 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	LianYi     = []byte{0x04, 0x86, 0x93, 0xc6, 0xd2, 0xf9, 0x72, 0x99, 0x48, 0x58, 0x61, 0x27, 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	MusicLeds  = []byte{0x04, 0x86, 0x90, 0x2e, 0x44, 0x2e, 0x77, 0x99, 0x48, 0x58, 0x61, 0x27, 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
)

func (ifd68 *Ifd68Pro) hidapi() {
	for _, pid := range productIDGD {
		if err := hid.Enumerate(vendorIDGD, uint16(pid), func(info *hid.DeviceInfo) error {
			//fmt.Println(info.Usage, info.UsagePage, info.Path, info.InterfaceNbr)
			if pid == 0x002c && info.InterfaceNbr == 2 {
				fmt.Printf("找到有线设备:%v %v", info.MfrStr, info.ProductStr)
				go ifd68.goRead(info)
			}
			if pid == 0x002d && info.Usage == 0 && info.UsagePage == 12 {
				fmt.Printf("注意：目前蓝牙还不支持 \n")
				fmt.Printf("找到无线设备:%v %v \n", info.MfrStr, info.ProductStr)
				go ifd68.goRead(info)
			}
			return nil
		}); err != nil {
			log.Fatal(err)
		}
	}
}
func (ifd68 *Ifd68Pro) goRead(info *hid.DeviceInfo) {
	fmt.Println(info.MfrStr, info.ProductStr)
	var err error
	ifd68.device, err = hid.OpenPath(info.Path)
	if err != nil {

	}
}

// BreathCheck 呼吸效果设定颜色
func (ifd68 *Ifd68Pro) BreathCheck() {
	R, G, B := ifd68.RGBConvert()
	ifd68.Breath = []byte{0x04, 0x86, 0x93, 0xcd, 0x7a, 0xd5, 0x72, 0x99, 0x49, byte(R), byte(G), byte(B), 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	ifd68.SendMsg = ifd68.Breath
}

// AlwaysCheck 常亮模式设定颜色
func (ifd68 *Ifd68Pro) AlwaysCheck() {
	R, G, B := ifd68.RGBConvert()
	ifd68.Alwayslight = []byte{0x04, 0x86, 0x93, 0xcc, 0x6a, 0x00, 0x72, 0x99, 0x49, byte(R), byte(G), byte(B), 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	ifd68.SendMsg = ifd68.Alwayslight
}

// KeySendMsg 发送消息到hid设备
func (ifd68 *Ifd68Pro) KeySendMsg() {
	//fmt.Println(ifd68.SendMsg)
	ifd68.device.Write(ifd68.SendMsg)
}

// setColor 根据传参设定颜色
func (ifd68 *Ifd68Pro) setColor() {
	switch ifd68.Color.ColorType {
	case "breath":
		ifd68.BreathCheck()
	case "fengche":
		ifd68.SendMsg = FENGCHE
	case "jianbian":
		ifd68.SendMsg = JianBian
	case "liuguang":
		ifd68.SendMsg = LiuGuang
	case "gundong":
		ifd68.SendMsg = GunDong
	case "lianyi":
		ifd68.SendMsg = LianYi
	case "changliang":
		ifd68.AlwaysCheck()
	case "yinlv":
		fmt.Println("")
	case "xinkong":
		ifd68.SendMsg = XinKong
	case "liangdu":
		ifd68.LightSet()
	//目前还不支持
	default:
		return
	}
	//fmt.Printf("type: %v \n msg: %v \n", ifd68.Color.ColorType, ifd68.SendMsg)
	ifd68.KeySendMsg()
}

// RGBConvert RGB转换成键盘需要的格式
func (ifd68 *Ifd68Pro) RGBConvert() (int, int, int) {
	var R, G, B int
	r, _ := strconv.Atoi(ifd68.ColorWeb.R)
	g, _ := strconv.Atoi(ifd68.ColorWeb.G)
	b, _ := strconv.Atoi(ifd68.ColorWeb.B)
	if R = r - 88; R < 0 {
		R = -R
	}
	if G = g - 97; G < 0 {
		G = -G
	}
	if B = b - 39; B < 0 {
		B = -B
	}
	return R, G, B
}

func (ifd68 *Ifd68Pro) Read() {
	buf := make([]byte, 64)
	for {
		fmt.Println("读取开始")
		n, err := ifd68.device.Read(buf)
		if err != nil {
		}
		fmt.Printf("%#X\n", buf[:n])
	}
}

// LightSet 亮度设置
func (ifd68 *Ifd68Pro) LightSet() {
	light, _ := strconv.Atoi(ifd68.ColorWeb.Lightness)
	ifd68.Light = []byte{0x04, 0x86, 0x94, 0xc1, 0x6a, byte(255 - light), 0x71, 0x98, 0x49, 0xed, 0x69, 0xd3, 0x59, 0x98, 0x8d, 0x75, 0x06, 0x95, 0xee, 0xed, 0x2f}
	ifd68.SendMsg = ifd68.Light
}

type Ifd68Pro struct {
	device      *hid.Device
	SendMsg     []byte
	Light       []byte
	Alwayslight []byte
	Breath      []byte
	Color       struct {
		ColorType string
		R         int
		G         int
		B         int
		Lightness int
	}
	ColorWeb struct {
		ColorType string `json:"color_type"`
		R         string `json:"r,omitempty"`
		G         string `json:"g,omitempty"`
		B         string `json:"b,omitempty"`
		Lightness string `json:"lightness,omitempty"`
	}
}
