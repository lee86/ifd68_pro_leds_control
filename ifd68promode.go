package main

import (
	"strconv"
	"time"
)

// Music 音律模式
func (ifd68 *Ifd68Pro) Music() {
	ifd68.SendMsg = []byte{0x04, 0x86, 0x93, 0xcf, 0x8a, 0xdc, 0xae, 0x9c, 0x4a, 0x59, 0x61, 0xd1, 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	ifd68.KeySendMsg()
	time.Sleep(150 * time.Millisecond)
	for {
		if !ifd68.MusicStatus {
			break
		}
		ifd68.SendMsg = []byte{0x04, 0x86, 0x90, 0xc3, 0x4a, 0x6d, 0x76, 0x99, 0x09, 0x4a, 0x5a, 0x10, 0x37, 0x8e, 0xf6, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
		ifd68.KeySendMsg()
		time.Sleep(120 * time.Millisecond)
		ifd68.SendMsg = []byte{0x04, 0x86, 0x90,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, // 音律13位数据位
			0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
		ifd68.KeySendMsg()
		time.Sleep(300 * time.Millisecond)
	}
}

// BreathCheck 呼吸效果设定颜色
func (ifd68 *Ifd68Pro) BreathCheck() {
	R, G, B := ifd68.RGBConvert()
	ifd68.Breath = []byte{0x04, 0x86, 0x93, 0xcd, 0x7a, 0xd5, 0x72, 0x99, 0x49, byte(R), byte(G), byte(B), 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	ifd68.SendMsg = ifd68.Breath
}

// AlwaysCheck 常亮模式设定颜色
func (ifd68 *Ifd68Pro) AlwaysCheck() {
	R, G, B := ifd68.RGBConvert()
	ifd68.Alwayslight = []byte{0x04, 0x86, 0x93, 0xcc, 0x6a, 0x00, 0x72, 0x99, 0x49, byte(R), byte(G), byte(B), 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	ifd68.SendMsg = ifd68.Alwayslight
}

// SetLight 亮度设置
func (ifd68 *Ifd68Pro) SetLight() {
	light, _ := strconv.Atoi(ifd68.ColorWeb.Lightness)
	if light = light - 242; light < 0 {
		light = -light
	}
	ifd68.Light = []byte{0x04, 0x86, 0x94, 0xc1, 0x6a, byte(light), 0x71, 0x98, 0x49, 0xed, 0x69, 0xd3, 0x59, 0x98, 0x8d, 0x75, 0x06, 0x95, 0xee, 0xed, 0x2f}
	ifd68.SendMsg = ifd68.Light
}

// SetOneKeyMove 单键移动
func (ifd68 *Ifd68Pro) SetOneKeyMove() {
	ifd68.SendMsg = []byte{0x04, 0x86, 0x93, 0xcf, 0x8a, 0xdc, 0xae, 0x9c, 0x4a, 0x59, 0x61, 0xd1, 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
	ifd68.KeySendMsg()
	time.Sleep(150 * time.Millisecond)
	ifd68.SendMsg = PersonSetON
	ifd68.KeySendMsg()
	for {
		for i := range keys {
			if values, ok := KeyValue[keys[i]]; ok {
				//fmt.Printf("%v,", i)
				x := values[0]
				y := values[1]
				if !ifd68.onkeyStatus {
					return
				}
				ifd68.SendMsg = []byte{0x04, 0x86, 0x9e, x, y, 0xf3, 0x73, 0x98, 0x48, 0x57, 0x9e, 0x27, 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
				ifd68.KeySendMsg()
				time.Sleep(200 * time.Millisecond)
				if !ifd68.onkeyStatus {
					return
				}
				ifd68.SendMsg = []byte{0x04, 0x86, 0x9e, x, y, 0xf3, 0x73, 0x98, 0xa8, 0x58, 0x68, 0x27, 0x58, 0xe8, 0x9a, 0x7f, 0x01, 0x95, 0xee, 0xed, 0x2f}
				ifd68.KeySendMsg()
			}
		}
	}
}
